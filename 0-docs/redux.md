# Redux - App-wider state management
- [Redux - App-wider state management](#redux---app-wider-state-management)
  - [Creating a redux slice](#creating-a-redux-slice)
  - [Configuring a redux store with slices](#configuring-a-redux-store-with-slices)
  - [Providing the store app-wide](#providing-the-store-app-wide)
  - [Reading stored states](#reading-stored-states)
  - [Changing / Dispatching new states](#changing--dispatching-new-states)
  - [Redux with side effects](#redux-with-side-effects)
    - [Handling the side effect in components](#handling-the-side-effect-in-components)
    - [Handling the side effect using redux action thunks](#handling-the-side-effect-using-redux-action-thunks)
      - [Creating an action thunk](#creating-an-action-thunk)
      - [Dispatching action thunk in component](#dispatching-action-thunk-in-component)

Redux is a substitute to useContext hook.

Using a context can make the JSX code non maintenable
Example: Consider our app component needs more than one context on it. Then the file will look like
```js
root.render(
    <AuthContextProvider>
        <CartContextProvider>
            <UiContextProvider>
                <ThemeContextProvider>
                    <App />
                </ThemeContextProvider>
            </UiContextProvider>
        </CartContextProvider>
    </AuthContextProvider>
);
```

This is not not easily maintenable, hence we use redux. A JS library that deals with creating app wide contexts easily using the concept of redux slices and provided only once to the entire App

## Creating a redux slice
> In **store/** create a file *counter.js* : This will have the context for the counter

```js
// creating a slice
// A slice helps to store states and reducer of a type - used to maintain when redux starts handling lot of states
const counterSlice = createSlice({
  name: "counter",
  initialState: {
    // Defining stored states
        counter: 0,
        showCounter: true,
    },
  reducers: {
    // Functions that can be called to perform changes on the stored states
    increment(state) {
        state.counter++;
    },
    decrement(state) {
        state.counter--;
    },
    increase(state, action) {
        //! action.payload will always hold the data coming into this action function (cannot change this property name)
      state.counter += action.payload; 
    },
    toggleCounter(state) {
        state.showCounter = !state.showCounter;
    },
    /* Note: You can see the states in the reducers are changed directly. 
    This does not mean they are mutable, the state copy and update is handled by redux internally.
    hence, we can update the state directly */
  },
});

// To dispatch new states, toolkit provides us with action functions these functions return a {} with a action-type generated by redux.
// These action functions can be called inside the dispatch hook to dispatch an action
export const counterActions = counterSlice.actions;
export default counterSlice;
```

## Configuring a redux store with slices
> Create a **store/** directory in the src/
>
> Create a *index.js*: this will be our entry point for redux store
```js
import { configureStore } from "@reduxjs/toolkit";
import counterSlice from "./counter";
import authSlice from "./auth";

// configureStore takes the reducers of all the redux-slices
const store = configureStore({
  reducer: {
    counter: counterSlice.reducer,
    auth: authSlice.reducer,
  },
});

export default store;
```

## Providing the store app-wide
> in *index.js*
```jsx
import { Provider } from "react-redux";
import store from "./store";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  // Providing a redux store to all components
  <Provider store={store}>
    <App />
  </Provider>
);
```
Now this store has access to all different contexts (slices) in a single declaration

## Reading stored states
```jsx
import { useSelector } from "react-redux";
const Counter = () => {
  // Subscribing to redux toolkit store & Extracting values of redux states
  const counter = useSelector((state) => state.counter.counter);
  const showCounter = useSelector((state) => state.counter.showCounter);

  return(
    {showCounter && <h1>{counter}</h1>}
  )
}
```

## Changing / Dispatching new states
```jsx
import { useSelector, useDispatch } from "react-redux";
import { counterActions } from "../store/counter";
const Counter = () => {
  // redux states
  const counter = useSelector((state) => state.counter.counter);
  const showCounter = useSelector((state) => state.counter.showCounter);

  // Get the redux dispatch function
  const dispatch = useDispatch();
  const incrementHandler = () => {
    // dispatching a redux-toolkit action
    dispatch(counterActions.increment());
  };
  const decrementHandler = () => {
    dispatch(counterActions.decrement());
  };
  const toggleCounterHandler = () => {
    dispatch(counterActions.toggleCounter());
  };
  const increaseHandler = () => {
    // Adding a payload to action
    dispatch(counterActions.increase(5));
  };

  return(
    {showCounter && <div>
        <div className={classes.value}>{counter}</div>
          <div>
            <button onClick={incrementHandler}>Increment</button>
            <button onClick={increaseHandler}>Raise by 5</button>
            <button onClick={decrementHandler}>Decrement</button>
          </div>
    </div>}
    <button onClick={toggleCounterHandler}>Toggle Counter</button>
  )
}
```

## Redux with side effects
**Note**: Reducers of slices should be pure, side-effect free and synchronous functions.
Hence we can not run any async code in reducers. But what if we want to store our latest state into the backend?

To do this we can use the following 2 approaches

### Handling the side effect in components
```jsx
import { useSelector, useDispatch } from "react-redux";
import { useEffect } from "react";
function App() {
  const cartIsVisible = useSelector((state) => state.ui.cartIsVisible);
  // Consider the example of storing the cart in the backend, so user does not looses the cart when he reloads
  // This can be done in the component itself, as follows
  // Get the entire instance of cart from the redux store ->
  // This will also be added as our dependency in useEffect
  const cart = useSelector((state) => state.cart);
  
  const dispatch = useDispatch();

  useEffect(() => {
    const sendCartData = async () => {
      const response = await fetch(
        "https://react-http-5463b-default-rtdb.firebaseio.com/cart.json",
        {
          method: "PUT",
          body: JSON.stringify(cart),
        }
      );
      if (!response.ok) {
        throw new Error("Failed to send cart data");
      }
    };

    sendCartData().catch((error) => {
      console.error(error)
    });
  }, [cart, dispatch]);

  return(
    <React.Fragment>
        {cartIsVisible && <Cart />}
    </React.Fragment>
  )
}
```

### Handling the side effect using redux action thunks
#### Creating an action thunk
```js
import { cartActions } from "./cart-slice";

// Creating a action thunk
// action thunk should return a function which will be called by the dispatcher automatically
// To get the action object and we can run side-effect (async) code here while
export const sendCartData = (cart) => {
  return async (dispatch) => {
    try {
      const response = await fetch(
        "https://react-http-5463b-default-rtdb.firebaseio.com/cart.json",
        {
          method: "PUT",
          body: JSON.stringify(cart),
        }
      );

      if (!response.ok) {
        throw new Error("Failed to send cart data");
      }
    } catch (error) {
        console.error(error)
    }
  };
};
```

#### Dispatching action thunk in component
```jsx
import { useSelector, useDispatch } from "react-redux";
import { useEffect } from "react";
import { sendCartData } from "./store/cart-thunks";
function App() {
  const cartIsVisible = useSelector((state) => state.ui.cartIsVisible);
  const cart = useSelector((state) => state.cart);
  const dispatch = useDispatch();

  useEffect(() => {
    // Using action thunks for side-effects in redux
    dispatch(sendCartData(cart));
  }, [cart, dispatch]);

  return(
    <React.Fragment>
        {cartIsVisible && <Cart />}
    </React.Fragment>
  )
}
```